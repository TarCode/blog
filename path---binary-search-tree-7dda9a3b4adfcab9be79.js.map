{"version":3,"sources":["webpack:///path---binary-search-tree-7dda9a3b4adfcab9be79.js","webpack:///./.cache/json/binary-search-tree.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/binary-search-tree.json","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","pathContext","path"],"mappings":"AAAAA,cAAc,iBAERC,4EACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,UAAAC,OAAA,kBAA4CC,gBAAmBC,GAAA,uHAAAC,KAAA,2qPAA2lOC,aAA4yBL,MAAA,wBAAAM,KAAA,wBAA8DC,aAAgBC,KAAA","file":"path---binary-search-tree-7dda9a3b4adfcab9be79.js","sourcesContent":["webpackJsonp([129919596472337],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/binary-search-tree.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Tarcode\",\"author\":\"Taariq Isaacs\"}},\"markdownRemark\":{\"id\":\"/Users/tarcode/Desktop/tarcode33/src/pages/2017-09-28-binary-search-tree/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>So. I‚Äôve tried out a couple of coding tests and one thing I keep seeing is the Binary Search Tree üò∞ (‚ÄúGoes on web hunt‚Äù).</p>\\n<p>I created a simple JS tutorial with an implementation of the Binary Search Tree and some methods based on the knowledge gathered on the web hunt üòº.</p>\\n<blockquote>\\n<p>A Binary Search Tree is a data structure that stores their objects with the keys in a sorted order so that lookup and other operations use the principle of Binary Search - When adding or looking for a key, traverse the tree from root to leaf, comparing the keys stored in the nodes of the tree and deciding, based on the comparison, whether to continue searching in the left or right subtrees.</p>\\n</blockquote>\\n<p><img src=\\\"https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/300px-Binary_search_tree.svg.png\\\" alt=\\\"bst\\\"></p>\\n<h2>Why Binary Search Tree?</h2>\\n<p>On average, each comparison allows the operations to skip about half the tree, so that each operation takes the time proportional to the logarithm of the number of items stored in the tree. Much better than <a href=\\\"https://en.wikipedia.org/wiki/Linear_time\\\">linear time</a> required to find items by key in an unsorted array, array, but slower than the corresponding operations on <a href=\\\"https://en.wikipedia.org/wiki/Hash_table\\\">hash tables</a> (Which is probably something we‚Äôll be looking at next time).</p>\\n<p>Create a js file and try these out to see the Binary Search Tree in action! üò¨ üòé ü§ì</p>\\n<h2>Creating a Binary Search Tree</h2>\\n<p>Create a node:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>function Node(val) {\\n    this.value = val\\n    this.left = null\\n    this.right = null\\n}</code></pre>\\n      </div>\\n<p>Create a constructor for the Binary Search Tree:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    function BinarySearchTree() {\\n        this.root = null\\n    }</code></pre>\\n      </div>\\n<p>The structure of a Binary Search Tree is as follows:</p>\\n<ul>\\n<li>Every node value on the left is smaller than the parent node (root)</li>\\n<li>Every node value on the right is larger than the parent node (root)</li>\\n</ul>\\n<p>This would require you to find the appropriate location when inserting.</p>\\n<p>Create the push method to check the node values and insert the value in the correct position:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    BinarySearchTree.prototype.push = function(val) {\\n        var root = this.root\\n\\n        if (!root) {\\n            this.root = new Node(val)\\n            return\\n        }\\n\\n        var currentNode = root\\n        var newNode = new Node(val)\\n\\n        while(currentNode) {\\n            if (val < currentNode.value) {\\n                if(!currentNode.left) {\\n                    currentNode.left = newNode\\n                    break\\n                } else {\\n                    currentNode = currentNode.left\\n                }\\n            } else {\\n                if (!currentNode.right) {\\n                    currentNode.right = newNode\\n                    break\\n                } else {\\n                    currentNode = currentNode.right\\n                }\\n            }\\n        }\\n    }</code></pre>\\n      </div>\\n<p>Once you have that, you can now create an instance of a Binary Search Tree and push values to it! üòÉ</p>\\n<p>Create an instance:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    var bst  = new BinarySearchTree()</code></pre>\\n      </div>\\n<p>Push some values:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    bst.push(40)\\n    bst.push(25)\\n    bst.push(10)\\n    bst.push(32)\\n    bst.push(78)</code></pre>\\n      </div>\\n<p>Now lets create some methods to traverse the tree and get the minimum and maximum values üòä</p>\\n<h3>Pre Order Traversal</h3>\\n<p>Traverses the tree from the parent node and visits the left side of the tree, left subtree-first, then proceeds to the right subtree.</p>\\n<p>So the values after the pre order traversal would correspond to:\\n<code>40, 25, 10, 32, 78</code></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    function preOrder(node) {\\n        if (node) {\\n            console.log(node.value)\\n            preOrder(node.left)\\n            preOrder(node.right)\\n        }\\n    }</code></pre>\\n      </div>\\n<h3>In Order Traversal</h3>\\n<p>Traverses the tree from the deepest left subtree, in order from smallest to largest value. </p>\\n<p>So the values after the in order traversal would correspond to:\\n<code>10, 25, 32, 40, 78</code></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    function inOrder(node) {\\n        if (node) {\\n            inOrder(node.left)\\n            console.log(node.value)\\n            inOrder(node.right)\\n        }\\n    }</code></pre>\\n      </div>\\n<h3>Post Order Traversal</h3>\\n<p>Traverses the deepest levels of the subtrees, left to right of the subtree, eventually reaching the parent node.</p>\\n<p>So the values after the post order traversal would correspond to:\\n<code>10, 32, 25, 78, 40</code></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    function postOrder(node) {\\n        if (node) {\\n            postOrder(node.left)\\n            postOrder(node.right)\\n            console.log(node.value)\\n        }\\n    }</code></pre>\\n      </div>\\n<p>Now lets call all the above methods and log a nice message above each one so we know which results we‚Äôre looking at!</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    console.log(\\\"Pre order traversal: \\\");\\n    preOrder(bst.root)\\n\\n    console.log(\\\"\\\\nIn order traversal: \\\");\\n    inOrder(bst.root)\\n\\n    console.log(\\\"\\\\nPost order traversal: \\\");\\n    postOrder(bst.root)</code></pre>\\n      </div>\\n<p>Sweet! The values log as expected. Now let‚Äôs create some methods to get the minimum and maximum values form the tree.</p>\\n<h3>Min Value</h3>\\n<p>Gets the smallest value from the tree:\\n<code>10</code></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    function minNode(node) {\\n        if (!node) {\\n            return 0\\n        }\\n        if (node.left) {\\n            return minNode(node.left)\\n        }\\n        return node.value\\n    }</code></pre>\\n      </div>\\n<h3>Max Value</h3>\\n<p>Gets the maximum value from the tree:\\n<code>78</code></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    function maxNode(node) {\\n        if (!node) {\\n            return 0\\n        }\\n        if (node.right) {\\n            return maxNode(node.right)\\n        }\\n        return node.value\\n    }</code></pre>\\n      </div>\\n<p>Lets log the minimum and maximum values:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    console.log(\\\"\\\\nMin Value: \\\");\\n    console.log(minNode(bst.root));\\n\\n    console.log(\\\"\\\\nMax Value: \\\");\\n    console.log(maxNode(bst.root));</code></pre>\\n      </div>\\n<p>Awesome! üò¨ üò¨ üò¨ </p>\\n<p>I hope this cleared the air about Binary Search Tree‚Äôs in even the slightest bit! </p>\\n<p>Check the Github repo for this tutorial:</p>\\n<ul>\\n<li><a href=\\\"https://github.com/TarCode/binary-search-tree-js\\\">Binary Search Tree in JS</a></li>\\n</ul>\\n<p>Check these out for some further reading (It‚Äôs what the tutorial is based off of):</p>\\n<ul>\\n<li>\\n<p><a href=\\\"http://rosettacode.org/wiki/Tree_traversal\\\">Rosetta Code: Tree Traversal</a></p>\\n</li>\\n<li>\\n<p><a href=\\\"https://khan4019.github.io/front-end-Interview-Questions/bst.html\\\">JS: Binary Search Tree</a></p>\\n</li>\\n<li>\\n<p><a href=\\\"https://en.wikipedia.org/wiki/Binary_search_tree\\\">Wikipedia: Binary Search Tree</a></p>\\n</li>\\n</ul>\\n<p>Happy Coding!!! üëΩ ü§ì üëæ</p>\",\"frontmatter\":{\"title\":\"Binary Search Tree JS\",\"date\":\"September 28, 2017\"}}},\"pathContext\":{\"path\":\"/binary-search-tree/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---binary-search-tree-7dda9a3b4adfcab9be79.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Tarcode\",\"author\":\"Taariq Isaacs\"}},\"markdownRemark\":{\"id\":\"/Users/tarcode/Desktop/tarcode33/src/pages/2017-09-28-binary-search-tree/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>So. I‚Äôve tried out a couple of coding tests and one thing I keep seeing is the Binary Search Tree üò∞ (‚ÄúGoes on web hunt‚Äù).</p>\\n<p>I created a simple JS tutorial with an implementation of the Binary Search Tree and some methods based on the knowledge gathered on the web hunt üòº.</p>\\n<blockquote>\\n<p>A Binary Search Tree is a data structure that stores their objects with the keys in a sorted order so that lookup and other operations use the principle of Binary Search - When adding or looking for a key, traverse the tree from root to leaf, comparing the keys stored in the nodes of the tree and deciding, based on the comparison, whether to continue searching in the left or right subtrees.</p>\\n</blockquote>\\n<p><img src=\\\"https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/300px-Binary_search_tree.svg.png\\\" alt=\\\"bst\\\"></p>\\n<h2>Why Binary Search Tree?</h2>\\n<p>On average, each comparison allows the operations to skip about half the tree, so that each operation takes the time proportional to the logarithm of the number of items stored in the tree. Much better than <a href=\\\"https://en.wikipedia.org/wiki/Linear_time\\\">linear time</a> required to find items by key in an unsorted array, array, but slower than the corresponding operations on <a href=\\\"https://en.wikipedia.org/wiki/Hash_table\\\">hash tables</a> (Which is probably something we‚Äôll be looking at next time).</p>\\n<p>Create a js file and try these out to see the Binary Search Tree in action! üò¨ üòé ü§ì</p>\\n<h2>Creating a Binary Search Tree</h2>\\n<p>Create a node:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>function Node(val) {\\n    this.value = val\\n    this.left = null\\n    this.right = null\\n}</code></pre>\\n      </div>\\n<p>Create a constructor for the Binary Search Tree:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    function BinarySearchTree() {\\n        this.root = null\\n    }</code></pre>\\n      </div>\\n<p>The structure of a Binary Search Tree is as follows:</p>\\n<ul>\\n<li>Every node value on the left is smaller than the parent node (root)</li>\\n<li>Every node value on the right is larger than the parent node (root)</li>\\n</ul>\\n<p>This would require you to find the appropriate location when inserting.</p>\\n<p>Create the push method to check the node values and insert the value in the correct position:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    BinarySearchTree.prototype.push = function(val) {\\n        var root = this.root\\n\\n        if (!root) {\\n            this.root = new Node(val)\\n            return\\n        }\\n\\n        var currentNode = root\\n        var newNode = new Node(val)\\n\\n        while(currentNode) {\\n            if (val < currentNode.value) {\\n                if(!currentNode.left) {\\n                    currentNode.left = newNode\\n                    break\\n                } else {\\n                    currentNode = currentNode.left\\n                }\\n            } else {\\n                if (!currentNode.right) {\\n                    currentNode.right = newNode\\n                    break\\n                } else {\\n                    currentNode = currentNode.right\\n                }\\n            }\\n        }\\n    }</code></pre>\\n      </div>\\n<p>Once you have that, you can now create an instance of a Binary Search Tree and push values to it! üòÉ</p>\\n<p>Create an instance:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    var bst  = new BinarySearchTree()</code></pre>\\n      </div>\\n<p>Push some values:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    bst.push(40)\\n    bst.push(25)\\n    bst.push(10)\\n    bst.push(32)\\n    bst.push(78)</code></pre>\\n      </div>\\n<p>Now lets create some methods to traverse the tree and get the minimum and maximum values üòä</p>\\n<h3>Pre Order Traversal</h3>\\n<p>Traverses the tree from the parent node and visits the left side of the tree, left subtree-first, then proceeds to the right subtree.</p>\\n<p>So the values after the pre order traversal would correspond to:\\n<code>40, 25, 10, 32, 78</code></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    function preOrder(node) {\\n        if (node) {\\n            console.log(node.value)\\n            preOrder(node.left)\\n            preOrder(node.right)\\n        }\\n    }</code></pre>\\n      </div>\\n<h3>In Order Traversal</h3>\\n<p>Traverses the tree from the deepest left subtree, in order from smallest to largest value. </p>\\n<p>So the values after the in order traversal would correspond to:\\n<code>10, 25, 32, 40, 78</code></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    function inOrder(node) {\\n        if (node) {\\n            inOrder(node.left)\\n            console.log(node.value)\\n            inOrder(node.right)\\n        }\\n    }</code></pre>\\n      </div>\\n<h3>Post Order Traversal</h3>\\n<p>Traverses the deepest levels of the subtrees, left to right of the subtree, eventually reaching the parent node.</p>\\n<p>So the values after the post order traversal would correspond to:\\n<code>10, 32, 25, 78, 40</code></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    function postOrder(node) {\\n        if (node) {\\n            postOrder(node.left)\\n            postOrder(node.right)\\n            console.log(node.value)\\n        }\\n    }</code></pre>\\n      </div>\\n<p>Now lets call all the above methods and log a nice message above each one so we know which results we‚Äôre looking at!</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    console.log(\\\"Pre order traversal: \\\");\\n    preOrder(bst.root)\\n\\n    console.log(\\\"\\\\nIn order traversal: \\\");\\n    inOrder(bst.root)\\n\\n    console.log(\\\"\\\\nPost order traversal: \\\");\\n    postOrder(bst.root)</code></pre>\\n      </div>\\n<p>Sweet! The values log as expected. Now let‚Äôs create some methods to get the minimum and maximum values form the tree.</p>\\n<h3>Min Value</h3>\\n<p>Gets the smallest value from the tree:\\n<code>10</code></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    function minNode(node) {\\n        if (!node) {\\n            return 0\\n        }\\n        if (node.left) {\\n            return minNode(node.left)\\n        }\\n        return node.value\\n    }</code></pre>\\n      </div>\\n<h3>Max Value</h3>\\n<p>Gets the maximum value from the tree:\\n<code>78</code></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    function maxNode(node) {\\n        if (!node) {\\n            return 0\\n        }\\n        if (node.right) {\\n            return maxNode(node.right)\\n        }\\n        return node.value\\n    }</code></pre>\\n      </div>\\n<p>Lets log the minimum and maximum values:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    console.log(\\\"\\\\nMin Value: \\\");\\n    console.log(minNode(bst.root));\\n\\n    console.log(\\\"\\\\nMax Value: \\\");\\n    console.log(maxNode(bst.root));</code></pre>\\n      </div>\\n<p>Awesome! üò¨ üò¨ üò¨ </p>\\n<p>I hope this cleared the air about Binary Search Tree‚Äôs in even the slightest bit! </p>\\n<p>Check the Github repo for this tutorial:</p>\\n<ul>\\n<li><a href=\\\"https://github.com/TarCode/binary-search-tree-js\\\">Binary Search Tree in JS</a></li>\\n</ul>\\n<p>Check these out for some further reading (It‚Äôs what the tutorial is based off of):</p>\\n<ul>\\n<li>\\n<p><a href=\\\"http://rosettacode.org/wiki/Tree_traversal\\\">Rosetta Code: Tree Traversal</a></p>\\n</li>\\n<li>\\n<p><a href=\\\"https://khan4019.github.io/front-end-Interview-Questions/bst.html\\\">JS: Binary Search Tree</a></p>\\n</li>\\n<li>\\n<p><a href=\\\"https://en.wikipedia.org/wiki/Binary_search_tree\\\">Wikipedia: Binary Search Tree</a></p>\\n</li>\\n</ul>\\n<p>Happy Coding!!! üëΩ ü§ì üëæ</p>\",\"frontmatter\":{\"title\":\"Binary Search Tree JS\",\"date\":\"September 28, 2017\"}}},\"pathContext\":{\"path\":\"/binary-search-tree/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/binary-search-tree.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/binary-search-tree.json\n// module chunks = 129919596472337"],"sourceRoot":""}